import os
import asyncio
import signal
import logging
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, MessageHandler,
    CallbackQueryHandler, filters, ContextTypes
)
from src.github_storage import get_storage

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ®Ø²ÙŠÙ†
storage = get_storage()


# ============================================
# Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø¨ÙˆØª
# ============================================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    user_id = str(user.id)
    
    # Ø­ÙØ¸/ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    existing = storage.get_user(user_id)
    storage.save_user(user_id, {
        "username": user.username,
        "first_name": user.first_name,
        "last_name": user.last_name or "",
        "first_seen": existing.get(
            "first_seen", datetime.now().isoformat()
        ) if existing else datetime.now().isoformat(),
        "last_active": datetime.now().isoformat(),
        "message_count": (
            existing.get("message_count", 0) if existing else 0
        )
    })
    
    # ØªØ°ÙƒØ± Ø¢Ø®Ø± Ø£Ù…Ø±
    storage.remember(
        f"last_command_{user_id}", "start", "user_actions"
    )
    
    if existing:
        first_seen = existing.get("first_seen", "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ")
        msg_count = existing.get("message_count", 0)
        await update.message.reply_text(
            f"Ù…Ø±Ø­Ø¨Ø§Ù‹ Ù…Ø¬Ø¯Ø¯Ø§Ù‹ {user.first_name}! ğŸ‘‹\n"
            f"Ø£ÙˆÙ„ Ø²ÙŠØ§Ø±Ø© Ù„Ùƒ: {first_seen}\n"
            f"Ø¹Ø¯Ø¯ Ø±Ø³Ø§Ø¦Ù„Ùƒ: {msg_count}\n"
            f"Ø£Ù†Ø§ Ø£ØªØ°ÙƒØ± ÙƒÙ„ Ø´ÙŠØ¡! ğŸ§ "
        )
    else:
        await update.message.reply_text(
            f"Ø£Ù‡Ù„Ø§Ù‹ {user.first_name}! ğŸ‘‹\n"
            f"Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ Ù„Ø£ÙˆÙ„ Ù…Ø±Ø©!\n"
            f"Ø³Ø£ØªØ°ÙƒØ± ÙƒÙ„ Ø´ÙŠØ¡ Ø¹Ù†Ùƒ ğŸ§ "
        )


async def save_note(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø­ÙØ¸ Ù…Ù„Ø§Ø­Ø¸Ø©"""
    user_id = str(update.effective_user.id)
    
    if not context.args:
        await update.message.reply_text("Ø§Ø³ØªØ®Ø¯Ù…: /save <Ø¹Ù†ÙˆØ§Ù†> <Ù…Ø­ØªÙˆÙ‰>")
        return
    
    title = context.args[0]
    content = " ".join(context.args[1:]) if len(context.args) > 1 else ""
    
    storage.set_value("notes", f"{user_id}_{title}", {
        "user_id": user_id,
        "title": title,
        "content": content,
        "created_at": datetime.now().isoformat()
    })
    
    await update.message.reply_text(
        f"âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©: {title}\n"
        f"Ù…Ø­ÙÙˆØ¸Ø© Ù„Ù„Ø£Ø¨Ø¯ Ø­ØªÙ‰ Ù„Ùˆ Ø£Ø¹Ø¯Øª ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª!"
    )


async def get_note(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ù…Ù„Ø§Ø­Ø¸Ø©"""
    user_id = str(update.effective_user.id)
    
    if not context.args:
        # Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª
        all_keys = storage.list_keys("notes")
        user_notes = [k for k in all_keys if k.startswith(f"{user_id}_")]
        
        if not user_notes:
            await update.message.reply_text("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ø­ÙÙˆØ¸Ø©.")
            return
        
        notes_list = "\n".join(
            [f"ğŸ“ {k.replace(f'{user_id}_', '')}" for k in user_notes]
        )
        await update.message.reply_text(
            f"Ù…Ù„Ø§Ø­Ø¸Ø§ØªÙƒ:\n{notes_list}\n\n"
            f"Ø§Ø³ØªØ®Ø¯Ù… /get <Ø¹Ù†ÙˆØ§Ù†> Ù„Ø¹Ø±Ø¶ Ù…Ù„Ø§Ø­Ø¸Ø©"
        )
        return
    
    title = context.args[0]
    note = storage.get_value("notes", f"{user_id}_{title}")
    
    if note:
        await update.message.reply_text(
            f"ğŸ“ {note['title']}\n\n"
            f"{note['content']}\n\n"
            f"ğŸ“… {note['created_at']}"
        )
    else:
        await update.message.reply_text("âŒ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©")


async def remember_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ°ÙƒØ± Ø´ÙŠØ¡"""
    user_id = str(update.effective_user.id)
    
    if len(context.args) < 2:
        await update.message.reply_text("Ø§Ø³ØªØ®Ø¯Ù…: /remember <Ù…ÙØªØ§Ø­> <Ù‚ÙŠÙ…Ø©>")
        return
    
    key = context.args[0]
    value = " ".join(context.args[1:])
    
    storage.remember(key, value, f"user_{user_id}")
    
    await update.message.reply_text(
        f"ğŸ§  Ø³Ø£ØªØ°ÙƒØ± Ø£Ù† {key} = {value}\n"
        f"ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ø³ØªØ±Ø¬Ø§Ø¹Ù‡Ø§ Ø¨Ù€ /recall {key}"
    )


async def recall_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø§Ø³ØªØ±Ø¬Ø§Ø¹ Ø°Ø§ÙƒØ±Ø©"""
    user_id = str(update.effective_user.id)
    
    if not context.args:
        # Ø¹Ø±Ø¶ ÙƒÙ„ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
        memories = storage.recall_all(f"user_{user_id}")
        if not memories:
            await update.message.reply_text("ğŸ§  Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙØ§Ø±ØºØ©!")
            return
        
        mem_list = "\n".join(
            [f"ğŸ”‘ {k}: {v}" for k, v in memories.items()]
        )
        await update.message.reply_text(f"ğŸ§  Ø°Ø§ÙƒØ±ØªÙƒ:\n{mem_list}")
        return
    
    key = context.args[0]
    value = storage.recall(key, f"user_{user_id}")
    
    if value:
        await update.message.reply_text(f"ğŸ§  {key} = {value}")
    else:
        await update.message.reply_text(f"âŒ Ù„Ø§ Ø£ØªØ°ÙƒØ± '{key}'")


async def stats_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ®Ø²ÙŠÙ†"""
    stats = storage.get_stats()
    
    text = (
        "ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªØ®Ø²ÙŠÙ†:\n\n"
        f"ğŸ“ Ù…Ù„ÙØ§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {stats['total_files']}\n"
        f"ğŸ‘¥ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {stats['users_count']}\n"
        f"ğŸ’¾ Ø§Ù„Ø¬Ù„Ø³Ø§Øª: {stats['sessions_count']}\n"
        f"ğŸ§  ÙØ¦Ø§Øª Ø§Ù„Ø°Ø§ÙƒØ±Ø©: {stats['memory_categories']}\n"
        f"ğŸ§  Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø°ÙƒØ±ÙŠØ§Øª: {stats.get('total_memories', 0)}\n"
        f"ğŸ“¦ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹Ø§Øª: {len(stats['collections'])}\n"
    )
    
    for col, count in stats["collections"].items():
        text += f"  â”” {col}: {count} Ø¹Ù†ØµØ±\n"
    
    text += f"\nâ³ Ù…Ù„ÙØ§Øª ØªÙ†ØªØ¸Ø± Ø§Ù„Ø­ÙØ¸: {stats['dirty_files']}"
    
    await update.message.reply_text(text)


async def force_save(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø­ÙØ¸ Ø¥Ø¬Ø¨Ø§Ø±ÙŠ"""
    storage.force_save_all()
    await update.message.reply_text("ğŸ’¾ ØªÙ… Ø­ÙØ¸ ÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø¹Ù„Ù‰ GitHub!")


async def backup_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©"""
    storage.create_backup()
    await update.message.reply_text("ğŸ”’ ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©!")


async def handle_message(update: Update, 
                          context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©"""
    user_id = str(update.effective_user.id)
    
    # ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
    user = storage.get_user(user_id)
    if user:
        user["message_count"] = user.get("message_count", 0) + 1
        user["last_message"] = update.message.text
        user["last_active"] = datetime.now().isoformat()
        storage.save_user(user_id, user)
    
    # Ø­ÙØ¸ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©
    storage.set_value("chat_log", f"{user_id}_{int(datetime.now().timestamp())}", {
        "user_id": user_id,
        "text": update.message.text,
        "timestamp": datetime.now().isoformat()
    })
    
    await update.message.reply_text(
        f"ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø±Ø³Ø§Ù„ØªÙƒ! (Ø§Ù„Ø±Ø³Ø§Ù„Ø© #{user.get('message_count', 1) if user else 1})"
    )


def main():
    """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
    bot_token = os.environ.get("BOT_TOKEN")
    if not bot_token:
        raise ValueError("ÙŠØ¬Ø¨ ØªØ¹ÙŠÙŠÙ† BOT_TOKEN")
    
    # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
    app = Application.builder().token(bot_token).build()
    
    # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø£ÙˆØ§Ù…Ø±
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("save", save_note))
    app.add_handler(CommandHandler("get", get_note))
    app.add_handler(CommandHandler("remember", remember_cmd))
    app.add_handler(CommandHandler("recall", recall_cmd))
    app.add_handler(CommandHandler("stats", stats_cmd))
    app.add_handler(CommandHandler("forcesave", force_save))
    app.add_handler(CommandHandler("backup", backup_cmd))
    app.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)
    )
    
    # Ø­ÙØ¸ Ø¹Ù†Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚
    def shutdown_handler(signum, frame):
        logger.info("ğŸ›‘ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚ ÙˆØ­ÙØ¸ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...")
        storage.force_save_all()
        logger.info("âœ… ØªÙ… Ø­ÙØ¸ ÙƒÙ„ Ø´ÙŠØ¡!")
    
    signal.signal(signal.SIGTERM, shutdown_handler)
    signal.signal(signal.SIGINT, shutdown_handler)
    
    logger.info("ğŸš€ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„!")
    app.run_polling(drop_pending_updates=True)


if __name__ == "__main__":
    main()
